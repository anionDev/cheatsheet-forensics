\raggedright
\footnotesize
\begin{multicols}{3}	
	\setlength{\premulticols}{1pt}
	\setlength{\postmulticols}{1pt}
	\setlength{\multicolsep}{1pt}
	\setlength{\columnsep}{2pt}

\begin{center}
     \Large{\underline{Reverse-Engineering}} \\
\end{center}

\section{Tools}
\settowidth{\MyLen}{\texttt{option.2.spa}}
\begin{tabular}{@{}p{\the\MyLen}
	@{}p{\linewidth-\the\MyLen}@{}}
	\texttt{.NET Reflector} & Programm zum Dekompilieren von .NET-Programmen.\\
	\texttt{IDA} &  Vollständiger Name: Interactive Disassembler. Von Microsoft entwickelter Disassembler, der Skripting erlaubt. \\
	\texttt{ildasm} & Einfacher GUI-basierter Disassembler für PE-Anwendungen, die IL-Code enthalten.\\
	\texttt{OllyDbg} & Etablierter Debugger für 32-Bit Anwendungen auf Windows.\\
	\texttt{WinDbg} & Debugger für Windows Kernel- und Usermode, der die Analyse von crash dumps und CPU-Register erlaubt.\\
\end{tabular}
\section{Libraries}
\subsubsection{MSVCRT.DLL}
Enthält die Funktionen der C-Standard-Bibliothek für den von Microsoft entwickelten Visual C++ Compiler von Version 4.2 bis 6.0.
\section{.NET-Programme}
Reverse Engineering von .Net-Programme ist relativ einfach. Dies hat im Wesentlichen 2 Gründe:
\begin{itemize}
\item Die originalen Bezeichner von Funktionen etc. werden ins kompilierte Binary einbezogen/übernommen und können beim Dekompilieren wieder ausgelesen werden.
\item Der .NET-Kompiler erzeugt generell Common-Intermediate-Language-Code, aus dem die Programmstruktur und damit der Source-Code generell relativ gut rekonstruiert werden können.
\end{itemize}
Es gibt deshalb Tools, die den Reverse-Engineering-Vorgang für .NET-Programme sehr leicht machen.
\end{multicols}